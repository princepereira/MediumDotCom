<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Identify Memory Leak Using pprof</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Identify Memory Leak Using pprof</h1>
</header>
<section data-field="subtitle" class="p-summary">
Memory Leak : If a program/application keeps consuming lot of memory and the memory heap doesn&#39;t goes down even after some specific period…
</section>
<section data-field="body" class="e-content">
<section name="7d06" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1ca4" id="1ca4" class="graf graf--h3 graf--leading graf--title">Identify Memory Leak Using pprof</h3><p name="f31c" id="f31c" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Memory Leak</strong> : If a program/application keeps consuming lot of memory and the memory heap doesn&#39;t goes down even after some specific period of time, then it is considered a memory leak in that program. Normally the heap rise should get constant and get garbage collected after some time. If it is not happening, then the graph will keep increasing and increasing and can crash the application due to OOM (Out Of memory) errors.</p><p name="9f0f" id="9f0f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How do we identify there is a memory leak ?</strong></p><p name="eb24" id="eb24" class="graf graf--p graf-after--p">We can use Prometheus, CAdvisor kind of opensource tools to keep monitoring the process and heap size. If the graph generated in tools gives a <strong class="markup--strong markup--p-strong">saw tooth</strong> kind of graph, then there is a memory leak.</p><figure name="9f69" id="9f69" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*N6EHD61rw4k_Pi-b.png" data-width="1400" data-height="887" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*N6EHD61rw4k_Pi-b.png"></figure><p name="de71" id="de71" class="graf graf--p graf-after--figure">Saw Tooth graph is generated due to following situation:</p><ul class="postList"><li name="208c" id="208c" class="graf graf--li graf-after--p">Memory heap keep increasing for a process running in docker and never it got garbage collected. Hence spike in the graph.</li><li name="1c10" id="1c10" class="graf graf--li graf-after--li">After exceeding some heap limit, OOM error (Out of Memory) will happen and process and docker will be killed. Hence the sudden fall in the graph.</li><li name="10ce" id="10ce" class="graf graf--li graf-after--li">According to docker restart policy, docker will come up again and the above steps continues.</li></ul><p name="1296" id="1296" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">How can we identify which part of the program is creating a memory leak ?</strong></p><p name="753a" id="753a" class="graf graf--p graf-after--p">Golang provides tool called <strong class="markup--strong markup--p-strong">pprof </strong>which has rich features to identify and track memory leak. Sample program gives an idea how to use it.</p><p name="a92e" id="a92e" class="graf graf--p graf-after--p">File: main.go</p><pre name="7706" id="7706" class="graf graf--pre graf-after--p">package main</pre><pre name="1f23" id="1f23" class="graf graf--pre graf-after--pre">import (<br>        &quot;fmt&quot;<br>        &quot;net/http&quot;<br>        _ &quot;net/http/pprof&quot;<br>        &quot;os&quot;<br>        &quot;time&quot;<br>)</pre><pre name="31eb" id="31eb" class="graf graf--pre graf-after--pre">func go_ticker() {<br>        fmt.Println(&quot;Started go_ticker&quot;)<br>        tick := time.Tick(time.Second / 100)<br>        var buf []byte<br>        for range tick {<br>                // This portion of code can increase memory<br>                buf = append(buf, make([]byte, 1024*1024)...)<br>        }<br>        fmt.Println(&quot;Finished go_ticker&quot;)<br>}</pre><pre name="4a99" id="4a99" class="graf graf--pre graf-after--pre">func norm_ticker() {<br>        fmt.Println(&quot;Started norm_ticker&quot;)<br>        tick := time.Tick(time.Second / 100)<br>        var buf []byte<br>        for range tick {<br>                // This portion of code can increase memory<br>                buf = append(buf, make([]byte, 1024*1024)...)<br>        }<br>        fmt.Println(&quot;Finished norm_ticker&quot;)<br>}</pre><pre name="fa03" id="fa03" class="graf graf--pre graf-after--pre">func norm_10() {<br>        var buf []byte<br>        fmt.Println(&quot;Started norm_10&quot;)<br>        for i := 0; i &lt; 10; i++ {<br>                buf = append(buf, make([]byte, 1024*1024)...)<br>        }<br>        fmt.Println(&quot;Finished norm_10&quot;)<br>}</pre><pre name="5e12" id="5e12" class="graf graf--pre graf-after--pre">func iter() {<br>        fmt.Println(&quot;Started iter&quot;)<br>        for i := 0; i &lt; 10; i++ {<br>                fmt.Println(&quot;Iteration : &quot;, i)<br>        }<br>        norm_ticker()<br>        fmt.Println(&quot;Finished iter&quot;)<br>}</pre><pre name="a66d" id="a66d" class="graf graf--pre graf-after--pre">// Run for a period of time: fatal error: runtime: out of memory<br>func main() {<br>        fmt.Println(&quot;Started main&quot;)<br>        // Open pprof<br>        go func() {<br>                ip := &quot;0.0.0.0:6060&quot;<br>                if err := http.ListenAndServe(ip, nil); err != nil {<br>                        fmt.Printf(&quot;start pprof failed on %s\n&quot;, ip)<br>                        os.Exit(1)<br>                }<br>        }()<br>        go go_ticker()<br>        norm_10()<br>        iter()<br>        fmt.Println(&quot;Finished main&quot;)<br>}</pre><p name="479f" id="479f" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">How to run and test ?</strong></p><pre name="6e31" id="6e31" class="graf graf--pre graf-after--p">$ go get -u github.com/google/<em class="markup--em markup--pre-em">pprof</em><br>$ go build -o binary<br>$ time ./binary // Running the binary with time // Run this in terminal 1<br>$ go tool pprof <a href="http://localhost:6060/debug/pprof/heap" data-href="http://localhost:6060/debug/pprof/heap" class="markup--anchor markup--pre-anchor" rel="nofollow" target="_blank">http://localhost:6060/debug/pprof/heap</a> // Generating a heap profile. Run this in terminal 2 when the above program is under execution<br>pprof&gt; top // List all high heap consuming functions<br>pprof&gt; top 5 // If your function list is too big, this command will show only top 5 functions<br>pprof&gt; list main.go_ticker // This will show the internals of function where exectly the heap is formed<br>pprof&gt; png // Generates a pictorial profile in PNG format<br>pprof&gt; pdf // Generates a pictorial profile in pdf format<br>pprof&gt; svg // Generates a pictorial profile in svg format</pre><p name="ab22" id="ab22" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Technical</strong></p><pre name="1d32" id="1d32" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">Flat and Flat%  :</strong> This will tell the memory allocated in that particular function</pre><pre name="4ba2" id="4ba2" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">Cum and Cum%    :</strong> This will tell the cumulative heap data which includes memory created in its stack as well as called func.<br>                : In above example main.main calls main.iter() which inturn calls main.norm_ticker. If norm_ticker makes 100MB data and main.iter() makes another 20MB, the cum of main.main() is 120MB.</pre><p name="b81e" id="b81e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Heap Profile from above code</strong></p><pre name="5e96" id="5e96" class="graf graf--pre graf-after--p">(pprof)<br>(pprof) top<br>Showing nodes accounting for 479.78MB, 100% of 479.78MB total<br>      flat  flat%   sum%        cum   cum%<br>  266.55MB 55.56% 55.56%   266.55MB 55.56%  main.go_ticker<br>  213.23MB 44.44%   100%   213.23MB 44.44%  main.norm_ticker<br>         0     0%   100%   213.23MB 44.44%  main.iter<br>         0     0%   100%   213.23MB 44.44%  main.main<br>         0     0%   100%   213.23MB 44.44%  runtime.main<br>(pprof)<br>(pprof)<br>(pprof)<br>(pprof) list main.norm_ticker<br>Total: 479.78MB<br>ROUTINE ======================== main.norm_ticker in /home/p4/Projects/go/sdpon/src/pprofandtrace/ticker/main.go<br>  213.23MB   213.23MB (flat, cum) 44.44% of Total<br>         .          .     21:func norm_ticker() {<br>         .          .     22:   fmt.Println(&quot;Started norm_ticker&quot;)<br>         .          .     23:   tick := time.Tick(time.Second / 100)<br>         .          .     24:   var buf []byte<br>         .          .     25:   for range tick {<br>  213.23MB   213.23MB     26:           buf = append(buf, make([]byte, 1024*1024)...)<br>         .          .     27:   }<br>         .          .     28:   fmt.Println(&quot;Finished norm_ticker&quot;)<br>         .          .     29:}<br>         .          .     30:<br>         .          .     31:func norm_10() {<br>(pprof)<br>(pprof)</pre><p name="b1ca" id="b1ca" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">PNG Graph generated from above execution</strong></p><figure name="3b66" id="3b66" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*L-QPkolAiny3PmSSWGBCiw.png" data-width="1177" data-height="669" src="https://cdn-images-1.medium.com/max/800/1*L-QPkolAiny3PmSSWGBCiw.png"></figure><p name="1a1d" id="1a1d" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Sample Program without Http package</strong></p><pre name="5b01" id="5b01" class="graf graf--pre graf-after--p">package main</pre><pre name="65ce" id="65ce" class="graf graf--pre graf-after--pre">import (<br>    &quot;encoding/json&quot;<br>    &quot;io/ioutil&quot;<br>    &quot;log&quot;<br>    &quot;os&quot;<br>    &quot;runtime&quot;<br>    &quot;runtime/pprof&quot;<br>)</pre><pre name="a228" id="a228" class="graf graf--pre graf-after--pre">func createHeapProfile() {<br>    f, err := os.Create(&quot;/tmp/heap.pprof&quot;)<br>    if err != nil {<br>            log.Fatal(err)<br>    }<br>    pprof.WriteHeapProfile(f)<br>    f.Close()<br>}</pre><pre name="3b5a" id="3b5a" class="graf graf--pre graf-after--pre">type A struct {<br>    Name string<br>}</pre><pre name="2379" id="2379" class="graf graf--pre graf-after--pre">type B struct {<br>    Li []A<br>}</pre><pre name="9f13" id="9f13" class="graf graf--pre graf-after--pre">func useIoutil(path string, jsonFile []byte) {<br>    err := ioutil.WriteFile(path, jsonFile, 0644)<br>    if err != nil {<br>            log.Fatal(&quot;Write-failed-for-key-values&quot;)<br>            return<br>    }<br>}</pre><pre name="f150" id="f150" class="graf graf--pre graf-after--pre">func main() {<br>    path := &quot;/tmp/db&quot;<br>    b := new(A)<br>    b.Name = &quot;Raj&quot;<br>    var li []A<br>    for i := 0; i &lt; 10000000; i++ {<br>            li = append(li, *b)<br>    }<br>    bkps := new(B)<br>    bkps.Li = li<br>    json.Marshal(bkps)<br>    jsonFile, _ := json.MarshalIndent(bkps, &quot;&quot;, &quot; &quot;)<br>    useIoutil(path, jsonFile)<br>    // runtime.GC() // This piece of code will execute immediate garbage collector.<br>    createHeapProfile()<br>}</pre><p name="88f6" id="88f6" class="graf graf--p graf-after--pre">How to analyze heap profile ?</p><pre name="4033" id="4033" class="graf graf--pre graf-after--p graf--trailing">$ go run main.go<br>$ go tool pprof /tmp/heap.pprof<br>File: main<br>Type: inuse_space<br>Time: Aug 2, 2021 at 4:59am (UTC)<br>Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)<br>(pprof) top<br>Showing nodes accounting for 572.06MB, 100% of 572.06MB total<br>Showing top 10 nodes out of 12<br>      flat  flat%   sum%        cum   cum%<br>  271.08MB 47.39% 47.39%   271.08MB 47.39%  bytes.makeSlice<br>  157.93MB 27.61% 74.99%   572.06MB   100%  main.main<br>  143.05MB 25.01%   100%   414.13MB 72.39%  encoding/json.Marshal<br>         0     0%   100%   271.08MB 47.39%  bytes.(*Buffer).WriteString<br>         0     0%   100%   271.08MB 47.39%  bytes.(*Buffer).grow<br>         0     0%   100%   271.08MB 47.39%  encoding/json.(*encodeState).marshal<br>         0     0%   100%   271.08MB 47.39%  encoding/json.(*encodeState).reflectValue<br>         0     0%   100%   271.08MB 47.39%  encoding/json.arrayEncoder.encode<br>         0     0%   100%   271.08MB 47.39%  encoding/json.ptrEncoder.encode<br>         0     0%   100%   271.08MB 47.39%  encoding/json.sliceEncoder.encode<br>(pprof)<br>(pprof) top 2<br>Showing nodes accounting for 429.01MB, 74.99% of 572.06MB total<br>Showing top 2 nodes out of 12<br>      flat  flat%   sum%        cum   cum%<br>  271.08MB 47.39% 47.39%   271.08MB 47.39%  bytes.makeSlice<br>  157.93MB 27.61% 74.99%   572.06MB   100%  main.main<br>(pprof)<br>(pprof)</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@princepereira" class="p-author h-card">Prince Pereira</a> on <a href="https://medium.com/p/a9340765ab9f"><time class="dt-published" datetime="2021-07-22T05:09:13.896Z">July 22, 2021</time></a>.</p><p><a href="https://medium.com/@princepereira/identify-memory-leak-using-pprof-a9340765ab9f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 28, 2022.</p></footer></article></body></html>